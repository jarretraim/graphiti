<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js">
<span id='graphiti-ResizeHandle'>/**
</span> * @class graphiti.ResizeHandle
 * The Resizehandles for Figures.

 * &lt;pre&gt;
 * Possible Type:
 * 
 *     1             2               3
 *     O-----------O-------------O
 *     |                         |
 *     |                         |
 *   8 O           + 9           O 4
 *     |                         |
 *     |                         |
 *     O-----------O-------------O
 *   7             6               5
 * &lt;/pre&gt;
 * 
 * @author Andreas Herz
 * @extends graphiti.Rectangle
 */
graphiti.ResizeHandle = graphiti.Rectangle.extend({
<span id='graphiti-ResizeHandle-method-constructor'>    /**
</span>     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     * 
     */
    init: function( canvas, type) {
 
      this._super(5,5);
         
      this.type = type;
      this.canvas = canvas;
      
      var offset= this.getWidth();
      var offset2 = offset/2;
      switch(this.type)
      {
        case 1:
          this.setSnapToGridAnchor(new graphiti.geo.Point(offset,offset));
          break;
        case 2:
          this.setSnapToGridAnchor(new graphiti.geo.Point(offset2,offset));
          break;
        case 3:
          this.setSnapToGridAnchor(new graphiti.geo.Point(0,offset));
          break;
        case 4:
          this.setSnapToGridAnchor(new graphiti.geo.Point(0,offset2));
          break;
        case 5:
          this.setSnapToGridAnchor(new graphiti.geo.Point(0,0));
          break;
        case 6:
          this.setSnapToGridAnchor(new graphiti.geo.Point(offset2,0));
          break;
        case 7:
          this.setSnapToGridAnchor(new graphiti.geo.Point(offset,0));
          break;
        case 8:
          this.setSnapToGridAnchor(new graphiti.geo.Point(offset,offset2));
        case 9:
          this.setSnapToGridAnchor(new graphiti.geo.Point(offset2,offset2));
          break;
      }
      
      this.setBackgroundColor(new  graphiti.util.Color(151,255,250));
      this.setZOrder(10000);
      this.setLineWidth(0.5);
    },
    
  
<span id='graphiti-ResizeHandle-method-createDraggable'>    /** 
</span>     * @private
     **/
    createDraggable:function()
    {
        this._startDrag = function (x,y,event) 
        {
           $.Event(event).stopPropagation();
           this.canvas.showMenu(null);
        
           if(!this.isDraggable())
             return;
             
           this.ox = this.x;
           this.oy = this.y;
        
           this.onDragstart(x,y);
        };
        this._moveDrag = function (dx, dy) 
        {
           if(this.isSelectable()===false)
             return;
           
           if(this.isDraggable()===false)
             return;
             
           this.onDrag(dx,dy);
        };
        this._upDrag = function () 
        {
           if(!this.isDraggable())
             return;
        
            this.onDragend();
        };
        this.shape.drag(this._moveDrag, this._startDrag, this._upDrag,this,this,this);
    },
    
<span id='graphiti-ResizeHandle-method-getSnapToDirection'>    /**
</span>     * @method
     * The edge of the rectangle for the snapTo mechanism.
     * 
     * @returns
     */
    getSnapToDirection:function()
    {
      switch(this.type)
      {
        case 1:
         return graphiti.SnapToHelper.NORTH_WEST;
        case 2:
         return graphiti.SnapToHelper.NORTH;
        case 3:
         return graphiti.SnapToHelper.NORTH_EAST;
        case 4:
         return graphiti.SnapToHelper.EAST;
        case 5:
         return graphiti.SnapToHelper.SOUTH_EAST;
        case 6:
         return graphiti.SnapToHelper.SOUTH;
        case 7:
         return graphiti.SnapToHelper.SOUTH_WEST;
        case 8:
         return graphiti.SnapToHelper.WEST;
        case 9:
         return graphiti.SnapToHelper.NSEW;
      }
    },
    

<span id='graphiti-ResizeHandle-method-onDragstart'>    /**
</span>     * @method
     * Will be called if the drag and drop action beginns. You can return [false] if you
     * want avoid that the figure can be move.
     * 
     * @type {boolean}
     **/
    onDragstart:function(/*:int*/ x, /*:int*/ y)
    {
      this.ox = this.x;
      this.oy = this.y;
      // This happens if the selected figure has set the &quot;nonResizeable&quot; flag
      // In this case the ResizeHandle can't be dragged. =&gt; no resize
      //
      if(!this.isDraggable())
        return false;
    
      var figure = this.canvas.currentSelection;
    
      this.commandMove  = figure.createCommand(new graphiti.EditPolicy(graphiti.EditPolicy.MOVE));
      this.commandResize= figure.createCommand(new graphiti.EditPolicy(graphiti.EditPolicy.RESIZE));
    
      return true;
    },
    
    
<span id='graphiti-ResizeHandle-method-onDrag'>    /**
</span>     *
     **/
    onDrag :function(/*:int*/ dx, /*:int*/ dy)
    {
      var oldX = this.getX();
      var oldY = this.getY();
      this._super(dx,dy);
      
      var diffX = this.getX()-oldX;
      var diffY = this.getY()-oldY;
  
      var obj = this.canvas.currentSelection;
      var objPosX = obj.getX();
      var objPosY = obj.getY();
      var objWidth= obj.getWidth();
      var objHeight= obj.getHeight();
      
      switch(this.type)
      {
        case 1:
            obj.setPosition(objPosX+diffX, objPosY+diffY);
            obj.setDimension(objWidth-diffX, objHeight-diffY);
          break;
        case 2:
            obj.setPosition(objPosX, objPosY+diffY);
            obj.setDimension(objWidth, objHeight-diffY);
          break;
        case 3:
            obj.setPosition(objPosX, objPosY-diffY);
            obj.setDimension(objWidth+diffX, objHeight-diffY);
          break;
        case 4:
            obj.setPosition(objPosX, objPosY);
            obj.setDimension(objWidth+diffX, objHeight);
          break;
        case 5:
            obj.setPosition(objPosX, objPosY);
            obj.setDimension(objWidth+diffX, objHeight+diffY);
          break;
        case 6:
            obj.setPosition(objPosX, objPosY);
            obj.setDimension(objWidth, objHeight+diffY);
          break;
        case 7:
            obj.setPosition(objPosX+diffX, objPosY);
            obj.setDimension(objWidth-diffX, objHeight+diffY);
          break;
        case 8:
            obj.setPosition(objPosX+diffX, objPosY);
            obj.setDimension(objWidth-diffX, objHeight);
          break;
      }
      this.canvas.moveResizeHandles(obj);
    },
    
<span id='graphiti-ResizeHandle-method-onDragend'>    /**
</span>     * Will be called after a drag and drop action.&lt;br&gt;
     * Sub classes can override this method to implement additional stuff. Don't forget to call
     * the super implementation via &lt;code&gt;Figure.prototype.onDragend.call(this);&lt;/code&gt;
     * @private
     **/
    onDragend : function()
    {
      var figure = this.canvas.currentSelection;
    
      // An non draggable resizeHandle doesn't create a move/resize command.
      // This happens if the selected figure has set the &quot;nonResizeable&quot; flag.
      //
      if(this.commandMove!=null)
      {
         this.commandMove.setPosition(figure.getX(), figure.getY());
         this.canvas.getCommandStack().execute(this.commandMove);
         this.commandMove = null;
      }
    
      if(this.commandResize!=null)
      {
         this.commandResize.setDimension(figure.getWidth(), figure.getHeight());
         this.canvas.getCommandStack().execute(this.commandResize);
         this.commandResize = null;
      }
    
      this.canvas.hideSnapToHelperLines();
    },
    
<span id='graphiti-ResizeHandle-method-setPosition'>    /**
</span>     * Set the position of the object.&lt;br&gt;
     * The ResizeHandle overrides the Figure.setPosition method. The base
     * class updates the resize handles during the update of the Dimension/Position. This
     * is not neccessary for the ResizeHandles. Performance issue.
     * 
     * @param {Number} xPos The new x coordinate of the figure
     * @param {Number} yPos The new y coordinate of the figure 
     **/
    setPosition:function(xPos ,yPos )
    {
      // don't call base implementation. Base implementation will show ResizeHandles...but I'm the ResizeHandle
      this.x = xPos;
      this.y = yPos;
      
      this.repaint();
    },
    
    
<span id='graphiti-ResizeHandle-method-show'>    /**
</span>     *
     **/
    show:function(canvas, /*:int*/x, /*:int*/y)
    {
      // don't call the parent function. The parent functions delete this object
      // and a resize handle can't be deleted.
      if(this.shape===null)
      {
         this.setCanvas(canvas);
         this.createShapeElement();
         this.createDraggable();
      }
      this.setPosition(x,y);
      this.shape.toFront();
    },
    
<span id='graphiti-ResizeHandle-method-hide'>    /**
</span>     *
     **/
    hide:function()
    {
      // don't call the parent function. The parent functions delete this object
      // and a resize handle shouldn't be deleted.
      if(this.shape===null)
        return;
        
      this.setCanvas(null);
    },
    
    
<span id='graphiti-ResizeHandle-property-supportsSnapToHelper'>    /**
</span>     * return true if the element can be used in combination with the 
     * SnapToHelper feature.
     *
     * @type boolean
     * @public
     **/
    supportsSnapToHelper:function()
    {
    	return true;
    },
    
    
<span id='graphiti-ResizeHandle-method-onKeyDown'>    /**
</span>     *
     **/
    onKeyDown:function(/*:int*/keyCode, /*:boolean*/ctrl)
    {
      // don't call the parent function. The parent functions delete this object
      // and a resize handle can't be deleted.
      this.canvas.onKeyDown(keyCode,ctrl);
    },
    
    
    fireMoveEvent:function()
    {
      // A resizeHandle doesn't fire this event.
      // Normally this set the document dirty. This is not necessary for a ResizeHandle.
    }
});</pre>
</body>
</html>
