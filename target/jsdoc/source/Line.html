<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='graphiti-Line'>/**
</span> * @class graphiti.Line
 * The base class for all visible elements inside a canvas.
 * 
 * @inheritable
 * @author Andreas Herz
 * @extends graphiti.Figure
 */
graphiti.Line = graphiti.Figure.extend({

<span id='graphiti-Line-method-constructor'>    /**
</span>     * @constructor
     * Creates a new figure element which are not assigned to any canvas.
     */
    init: function( ) {
        this._super();
        
        this.lineColor = new  graphiti.util.Color(0,0,0);
        this.stroke=1;
        this.startX = 30;
        this.startY = 30;
        
        this.endX   = 100;
        this.endY   = 100;
        
        this.isMoving = false;

        this.model = null; // model for the MVC pattern
        

        // click area for the line hit test
        this.corona = 20;

        // a figure can store additional, user defined, properties
        this.properties = new Object(); /*:Map&lt;name,value&gt;*/

        this.setSelectable(true);
        this.setDeleteable(true);
   },
      

<span id='graphiti-Line-method-setCoronaWidth'>   /**
</span>    * Set the width for the click hit test of this line.
    *
    * @param {int} width the width of the line hit test.
    **/
   setCoronaWidth:function(/*:int*/ width)
   {
      this.corona = width;
   },


<span id='graphiti-Line-method-createShapeElement'>   /**
</span>    * Called by the framework. Don't call them manually.
    * @private
    **/
   createShapeElement:function()
   {
     return this.canvas.paper.path(&quot;M&quot;+this.getStartX()+&quot; &quot;+this.getStartY()+&quot;L&quot;+this.getEndX()+&quot; &quot;+this.getEndY());
   },

   repaint:function()
   {
     this._super({&quot;stroke&quot;:&quot;#&quot;+this.lineColor.hex(),
                  &quot;stroke-width&quot;:this.stroke,
                  &quot;path&quot;:&quot;M&quot;+this.getStartX()+&quot; &quot;+this.getStartY()+&quot;L&quot;+this.getEndX()+&quot; &quot;+this.getEndY()});
   },

<span id='graphiti-Line-method-setCanvas'>   /**
</span>    * @private
    * @param {graphiti.Canvas} canvas
    **/
   setCanvas:function( canvas)
   {
     if(canvas===null &amp;&amp; this.shape!==null)
     {
        this.shape.remove();
        this.shape = null;
     }
     this.canvas = canvas;
   },

<span id='graphiti-Line-property-getCanvas'>   /**
</span>    * @type graphiti.Canvas
    **/
   getCanvas:function()
   {
      return this.canvas;
   },
   
<span id='graphiti-Line-method-setId'>   /**
</span>    * Set the unique id of this element.
    *
    * @param {String} id The new unique id of this element
    * @since 0.9.15
    **/
   setId:function(/*:String*/ id)
   {
     this.id=id;
   },

<span id='graphiti-Line-property-getProperties'>   /**
</span>    * A figure can store user defined attributes. This method returns all properties stored in this figure.&lt;br&gt;
    *
    * @see #setProperty
    * @returns All user defined properties of the figure
    * @type Map
    **/
   getProperties:function()
   {
     return this.properties;
   },

<span id='graphiti-Line-property-getProperty'>   /**
</span>    * A figure can store user defined attributes. This method returns the requested property.&lt;br&gt;
    *
    * @see #setProperty
    * @returns The user defined property of this figure.
    * @type String
    **/
   getProperty:function(/*:String*/ key)
   {
     return this.properties[key];
   },


<span id='graphiti-Line-method-setProperty'>   /**
</span>    * A figure can store any type of information. You can use this to attach any String or Object to this
    * figure.
    *
    * @see #getProperty
    * @param {String} key The key of the property.
    * @param {String} value The value of the property.
    **/
   setProperty:function(/*:String*/ key,/*:String*/ value)
   {
     this.properties[key]=value;
     this.setDocumentDirty();
   },


<span id='graphiti-Line-property-getWorkflow'>   /**
</span>    * @type Workflow
    **/
   getWorkflow:function()
   {
      return this.workflow;
   },


<span id='graphiti-Line-property-isResizeable'>   /**
</span>    * You can't drag&amp;drop the resize handles if the line not resizeable.
    * @type boolean
    **/
   isResizeable:function()
   {
     return true;
   },


<span id='graphiti-Line-method-attachMoveListener'>   /**
</span>    * 
    * @param {graphiti.Figure} figure The figure to monitor any movements
    **/
   attachMoveListener:function(/*:graphiti.Figure*/ figure)
   {
     this.moveListener.add(figure);
   },

<span id='graphiti-Line-method-detachMoveListener'>   /**
</span>    *
    * @param {graphiti.Figure} figure The figure to to remove the movement monitor
    **/
   detachMoveListener:function(/*:graphiti.Figure*/ figure) 
   {
     this.moveListener.remove(figure);
   },

<span id='graphiti-Line-method-fireMoveEvent'>   /**
</span>    *
    * @private
    **/
   fireMoveEvent:function()
   {
     var size= this.moveListener.getSize();
     for(var i=0;i&lt;size;i++)
     {
       this.moveListener.get(i).onOtherFigureMoved(this);
     }
   },

<span id='graphiti-Line-method-onOtherFigureMoved'>   /**
</span>    * This method will be called if an figure, which has been registered befor, has been moved.
    *
    * @param {graphiti.Figure} figure The figure which has been moved
    * @private
    **/
   onOtherFigureMoved:function(/*:graphiti.Figure*/ figure)
   {
   },

<span id='graphiti-Line-method-setLineWidth'>   /**
</span>    * Set the line width. This enforce a repaint of the line.
    * This method fires a &lt;i&gt;document dirty&lt;/i&gt; event.
    *
    * @param {int} w The new line width of the figure.
    **/
   setLineWidth:function(/*:int*/ w)
   {
     this.stroke=w;
     this.setDocumentDirty();
     
     if(this.shape!==null)
        this.shape.attr({&quot;stroke-width&quot;:this.stroke});
   },


<span id='graphiti-Line-method-setColor'>   /**
</span>    * Set the color of the line.
    * This method fires a &lt;i&gt;document dirty&lt;/i&gt; event.
    * @param {graphiti.Color} color The new color of the line.
    **/
   setColor:function(/*:graphiti.Color*/ color)
   {
     this.lineColor = color;
     this.setDocumentDirty();

     if(this.shape!==null)
        this.shape.attr({&quot;stroke&quot;:&quot;#&quot;+this.lineColor.hex()});
   },

<span id='graphiti-Line-property-getColor'>   /**
</span>    * Return the current paint color.
    * @type graphiti.Color The paint color of the line.
    **/
   getColor:function()
   {
     return this.lineColor;
   },

<span id='graphiti-Line-method-setStartPoint'>   /**
</span>    * Set the start point of the line.
    * This method fires a &lt;i&gt;document dirty&lt;/i&gt; event.
    *
    * @param {int} x the x coordinate of the start point
    * @param {int} y the y coordinate of the start point
    **/
   setStartPoint:function(/*:int*/ x, /*:int*/ y)
   {
     if(this.startX==x &amp;&amp; this.startY==y)
        return;

     this.startX = x;
     this.startY = y;
     this.repaint();
     this.setDocumentDirty();
   },

<span id='graphiti-Line-method-setEndPoint'>   /**
</span>    * Set the end point of the line.
    * This method fires a &lt;i&gt;document dirty&lt;/i&gt; event.
    *
    * @param {int} x the x coordinate of the end point
    * @param {int} y the y coordinate of the end point
    **/
   setEndPoint:function(/*:int*/x, /*:int*/ y)
   {
     if(this.endX==x &amp;&amp; this.endY==y)
        return;

     this.endX = x;
     this.endY = y;
     this.repaint();
     this.setDocumentDirty();
   },

<span id='graphiti-Line-property-getStartX'>   /**
</span>    * @type int
    **/
   getStartX:function()
   {
     return this.startX;
   },

<span id='graphiti-Line-property-getStartY'>   /**
</span>    *
    * @type int
    **/
   getStartY:function()
   {
     return this.startY;
   },

<span id='graphiti-Line-method-getStartPoint'>   /**
</span>    *
    * @return graphiti.geo.Point
    **/
   getStartPoint:function()
   {
     return new graphiti.geo.Point(this.startX,this.startY);
   },


<span id='graphiti-Line-property-getEndX'>   /**
</span>    *
    * @type int
    **/
   getEndX:function()
   {
     return this.endX;
   },

<span id='graphiti-Line-property-getEndY'>   /**
</span>    *
    * @type int
    **/
   getEndY:function()
   {
     return this.endY;
   },

<span id='graphiti-Line-method-getEndPoint'>   /**
</span>    *
    * @return graphiti.geo.Point
    **/
   getEndPoint:function()
   {
     return new graphiti.geo.Point(this.endX,this.endY);
   },


<span id='graphiti-Line-property-isSelectable'>   /**
</span>    * Return true if the user can select the line.
    * @type boolean
    **/
   isSelectable:function()
   {
     return this.selectable;
   },


<span id='graphiti-Line-method-setSelectable'>   /**
</span>    * You can change the selectable behaviour of this object. Hands over [false] and
    * the figure has no selection handles if you try to select them with the mouse.&lt;br&gt;
    *
    * @param {boolean} flag The selectable flag.
    **/
   setSelectable:function(/*:boolean*/ flag)
   {
     this.selectable=flag;
   },


<span id='graphiti-Line-property-isDeleteable'>   /**
</span>    * Return false if you avoid that the user can delete your figure.
    * Sub class can override this method.
    * @type boolean
    **/
   isDeleteable:function()
   {
     return this.deleteable;
   },

<span id='graphiti-Line-property-setDeleteable'>   /**
</span>    * Return false if you avoid that the user can delete your figure.
    * Sub class can override this method.
    * @type boolean
    **/
   setDeleteable:function(/*:boolean */flag)
   {
     this.deleteable = flag;
   },


<span id='graphiti-Line-property-getLength'>   /**
</span>    * Returns the length of the line.
    * 
    * @type int
    **/
   getLength:function()
   {
     // call native path method if possible
     if(this.shape!==null)
       return this.shape.getTotalLength();
       
     return Math.sqrt((this.startX-this.endX)*(this.startX-this.endX)+(this.startY-this.endY)*(this.startY-this.endY));
   },

<span id='graphiti-Line-property-getAngle'>   /**
</span>    * Returns the angle of the line in degree
    *
    * &lt;pre&gt;
    *                                 270°
    *                               |
    *                               |
    *                               |
    *                               |
    * 180° -------------------------+------------------------&gt; +X
    *                               |                        0°
    *                               |
    *                               |
    *                               |
    *                               V +Y
    *                              90°
    * &lt;/pre&gt;
    * @type float
    **/
   getAngle:function()
   {
     var length = this.getLength();
     var angle = -(180/Math.PI) *Math.asin((this.startY-this.endY)/length);

     if(angle&lt;0)
     {
        if(this.endX&lt;this.startX)
          angle = Math.abs(angle) + 180;
        else
          angle = 360- Math.abs(angle);
     }
     else
     {
        if(this.endX&lt;this.startX)
          angle = 180-angle;
     }
     return angle;
   },

   /**
<span id='graphiti-Line-property-createCommand'>    * Returns the Command to perform the specified Request or null.
</span>     *
    * @param {graphiti.EditPolicy} request describes the Command being requested
    * @return null or a Command
    * @type graphiti.Command 
    * @since 0.9.15
    **/
   createCommand:function(/*:graphiti.EditPolicy*/ request)
   {
     if(request.getPolicy() == graphiti.EditPolicy.MOVE)
     {
       var x1 = this.getStartX();
       var y1 = this.getStartY();
       var x2 = this.getEndX();
       var y2 = this.getEndY();
       return new graphiti.command.CommandMoveLine(this,x1,y1,x2,y2);
     }
     if(request.getPolicy() == graphiti.EditPolicy.DELETE)
     {
        if(this.isDeleteable()==false)
           return null;
        return new graphiti.command.CommandDelete(this);
     }
     return null;
   },


   /**
<span id='graphiti-Line-method-setModel'>    * Set the primary model object that this Line represents. This method is used 
</span>    * by an EditPartFactory when creating an Line.
    * 
    * @param {graphiti.AbstractObjectModel} model The model
    * @since 0.9.15
    * @final
    */
   setModel:function(/*:graphiti.AbstractObjectModel*/ model)
   {
      if(this.model!=null)
         this.model.removePropertyChangeListener(this);

      this.model = model;

      if(this.model!=null)
         this.model.addPropertyChangeListener(this);
   },


   /**
<span id='graphiti-Line-property-getModel'>    * Returns the primary model object that this Figure represents.
</span>    * 
    * @type {graphiti.AbstractObjectModel}
    * @final
    */
   getModel:function()
   {
      return this.model;
   },

   /**
<span id='graphiti-Line-method-onDoubleClick'>    * Callback method for the double click event of user interaction.
</span>    * Sub classes can override this method to implement their own behaviour.
    **/
   onDoubleClick:function()
   {
   },


   /**
<span id='graphiti-Line-property-containsPoint'>    * Checks if the hands over coordinate on the line.
</span>    *
    * @param {Number} px the x coordinate of the test point
    * @param {Number} py the y coordinate of the test point
    * @type boolean
    **/
   containsPoint: function( px, py)
   {
     return graphiti.Line.hit(this.corona, this.startX,this.startY, this.endX, this.endY, px,py);
   }

});

/**
<span id='graphiti-Line-static-method-hit'> * Static util function to determine is a point(px,py) on the line(x1,y1,x2,y2)
</span> * A simple hit test.
 * 
 * @return {boolean}
 * @static
 * @private
 * @param {Number} coronaWidth the accepted corona for the hit test
 * @param {Number} X1 x coordinate of the start point of the line
 * @param {Number} Y1 y coordinate of the start point of the line
 * @param {Number} X2 x coordinate of the end point of the line
 * @param {Number} Y2 y coordinate of the end point of the line
 * @param {Number} px x coordinate of the point to test
 * @param {Number} py y coordinate of the point to test
 **/
graphiti.Line.hit= function( coronaWidth, X1, Y1,  X2,  Y2, px, py)
{
  // Adjust vectors relative to X1,Y1
  // X2,Y2 becomes relative vector from X1,Y1 to end of segment
  X2 -= X1;
  Y2 -= Y1;
  // px,py becomes relative vector from X1,Y1 to test point
  px -= X1;
  py -= Y1;
  var dotprod = px * X2 + py * Y2;
  var projlenSq;
  if (dotprod &lt;= 0.0) {
      // px,py is on the side of X1,Y1 away from X2,Y2
      // distance to segment is length of px,py vector
      // &quot;length of its (clipped) projection&quot; is now 0.0
      projlenSq = 0.0;
  } else {
      // switch to backwards vectors relative to X2,Y2
      // X2,Y2 are already the negative of X1,Y1=&gt;X2,Y2
      // to get px,py to be the negative of px,py=&gt;X2,Y2
      // the dot product of two negated vectors is the same
      // as the dot product of the two normal vectors
      px = X2 - px;
      py = Y2 - py;
      dotprod = px * X2 + py * Y2;
      if (dotprod &lt;= 0.0) {
          // px,py is on the side of X2,Y2 away from X1,Y1
          // distance to segment is length of (backwards) px,py vector
          // &quot;length of its (clipped) projection&quot; is now 0.0
          projlenSq = 0.0;
      } else {
          // px,py is between X1,Y1 and X2,Y2
          // dotprod is the length of the px,py vector
          // projected on the X2,Y2=&gt;X1,Y1 vector times the
          // length of the X2,Y2=&gt;X1,Y1 vector
          projlenSq = dotprod * dotprod / (X2 * X2 + Y2 * Y2);
      }
  }
    // Distance to line is now the length of the relative point
    // vector minus the length of its projection onto the line
    // (which is zero if the projection falls outside the range
    //  of the line segment).
    var lenSq = px * px + py * py - projlenSq;
    if (lenSq &lt; 0) {
        lenSq = 0;
    }
    return Math.sqrt(lenSq)&lt;coronaWidth;
};</pre>
</body>
</html>
