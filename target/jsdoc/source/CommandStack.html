<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <title>The source code</title>
  <link href="../resources/prettify/prettify.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="../resources/prettify/prettify.js"></script>
  <style type="text/css">
    .highlight { display: block; background-color: #ddd; }
  </style>
  <script type="text/javascript">
    function highlight() {
      document.getElementById(location.hash.replace(/#/, "")).className = "highlight";
    }
  </script>
</head>
<body onload="prettyPrint(); highlight();">
  <pre class="prettyprint lang-js"><span id='graphiti-command-CommandStack'>/**
</span> * @class graphiti.command.CommandStack
 * Stack for undo/redo operations
 */
graphiti.command.CommandStack = Class.extend({

<span id='PRE_EXECUTE'>	/** Constant indicating notification prior to executing a command (value is 1).*/
</span>	PRE_EXECUTE:1,
<span id='PRE_REDO'>	/** Constant indicating notification prior to redoing a command (value is 2).*/
</span>	PRE_REDO:2,
<span id='PRE_UNDO'>	/** Constant indicating notification prior to undoing a command (value is 4).*/
</span>	PRE_UNDO:4,
<span id='POST_EXECUTE'>	/**  Constant indicating notification after a command has been executed (value is 8).*/
</span>	POST_EXECUTE:8,
<span id='POST_REDO'>	/** Constant indicating notification after a command has been redone (value is 16).*/
</span>	POST_REDO:16,
<span id='POST_UNDO'>	/** Constant indicating notification after a command has been undone (value is 32).*/
</span>	POST_UNDO:32,

	POST_MASK : this.POST_EXECUTE | this.POST_UNDO | this.POST_REDO,
	PRE_MASK  : this.PRE_EXECUTE  | this.PRE_UNDO  |this. PRE_REDO,

<span id='POST_UNDO-method-constructor'>    /**
</span>     * @constructor
     * Create a new CommandStack objects which can be execute via the CommandStack.
     * 
     */
    init : function( ) {
       this.undostack = [];
       this.redostack = [];
       this.maxundo = 50;
       this.eventListeners = new graphiti.util.ArrayList();
    },
    
 
<span id='POST_UNDO-method-setUndoLimit'>    /**
</span>     * @method
     * Set the maximal undo stack size. Entries will be remove if the max. stack 
     * size has been reached.
     *
     * @param {Number} count The maximal undo stack size.
     * 
     **/
    setUndoLimit:function( count)
    {
      this.maxundo = count;
    },
    
<span id='POST_UNDO-method-markSaveLocation'>    /**
</span>     * @method
     * Remove the undo / redo history. This is useful if the user has been save the 
     * document.
     *
     **/
    markSaveLocation:function()
    {
       this.undostack = [];
       this.redostack = [];
    },
    
<span id='POST_UNDO-method-execute'>    /**
</span>     * @method
     * 
     * Executes the specified Command if possible. Prior to executing the command, a
     * graphiti.command.CommandStackEvent for {@link #PRE_EXECUTE} will be fired to event listeners. 
     * Similarly, after attempting to execute the command, an event for {@link #POST_EXECUTE}
     * will be fired.
     *
     * @param {graphiti.command.Command} command The command to execute.
     * 
     **/
    execute:function(command)
    {
       // nothing to do
       if(command===null)
          return; //silently
    
       if(typeof command === &quot;undefined&quot;)
          throw &quot;Missing parameter [command] for method call CommandStack.execute&quot;;
          
       // return if the command can't execute or it doesn't change the model
       // =&gt; Empty command
       if(command.canExecute()===false)
          return;
    
       this.notifyListeners(command, graphiti.command.CommandStack.PRE_EXECUTE);
    
       this.undostack.push(command);
       command.execute();
    
       // cleanup the redo stack if the user execute a new command.
       // I think this will create a &quot;clean&quot; behaviour of the unde/redo mechanism.
       //
       this.redostack = [];
    
       // monitor the max. undo stack size
       //
       if(this.undostack.length &gt; this.maxundo)
       {
          this.undostack = this.undostack.slice(this.undostack.length-this.maxundo);
       }
       this.notifyListeners(command, graphiti.command.CommandStack.POST_EXECUTE);
    },
    
<span id='POST_UNDO-method-undo'>    /**
</span>     * @method
     * Undo on command from the stack and store them on the redo command stack.
     *
     **/
    undo:function()
    {
       var command = this.undostack.pop();
       if(command)
       {
          this.notifyListeners(command, graphiti.command.CommandStack.PRE_UNDO);
          this.redostack.push(command);
          command.undo();
          this.notifyListeners(command, graphiti.command.CommandStack.POST_UNDO);
       }
    },
    
<span id='POST_UNDO-method-redo'>    /** 
</span>     * @method
     * Redo a command after the user has undo a command
     *
     **/
    redo:function()
    {
       var command = this.redostack.pop();
    
       if(command)
       {
          this.notifyListeners(command, graphiti.command.CommandStack.PRE_REDO);
          this.undostack.push(command);
          command.redo();
          this.notifyListeners(command, graphiti.command.CommandStack.POST_REDO);
       }
    },
    
<span id='POST_UNDO-method-getRedoLabel'>    /**
</span>     * @method
     * Return the label of the next REDO command.
     *
     * @return {String}
    **/
    getRedoLabel:function()
    {
       if(this.redostack.lenght===0)
         return &quot;&quot;;
         
       var command = this.redostack[this.redostack.length-1];
    
       if(command)
       {
          return command.getLabel();
       }
       return &quot;&quot;;
    },
    
    
<span id='POST_UNDO-method-getUndoLabel'>    /**
</span>     * @method
     * Return the label of the next UNDO command.
     *
     * @return {String}
     **/
    getUndoLabel:function()
    {
       if(this.undostack.lenght===0)
         return &quot;&quot;;
         
       var command = this.undostack[this.undostack.length-1];
    
       if(command)
       {
          return command.getLabel();
       }
       return &quot;&quot;;
    },
    
    
<span id='POST_UNDO-method-canRedo'>    /**
</span>     * @method
     * Indicates whenever a REDO is possible.
     * 
     * @return boolean &lt;code&gt;true&lt;/code&gt; if it is appropriate to call {@link #redo()}.
     */
    canRedo:function()
    {
       return this.redostack.length&gt;0;
    },
    
<span id='POST_UNDO-method-canUndo'>    /**
</span>     * @method 
     * indicator whenever a undo is possible.
     * 
     * @return {boolean} &lt;code&gt;true&lt;/code&gt; if {@link #undo()} can be called
     **/ 
    canUndo:function()
    {
       return this.undostack.length&gt;0;
    },
    
<span id='POST_UNDO-method-addCommandStackEventListener'>    /**
</span>     * @method
     * Adds a listener to the command stack, which will be notified whenever a command has been processed on the stack.
     * 
     * @param {graphiti.command.CommandStackListener} listener the listener to add.
     */
    addCommandStackEventListener:function( listener)
    {
        if(listener instanceof graphiti.command.CommandStackEventListener)
          this.eventListeners.add(listener);
        else
          throw &quot;Object doesn't implement required callback interface [graphiti.command.CommandStackListener]&quot;;
    },
    
<span id='POST_UNDO-method-removeCommandStackEventListener'>    /**
</span>     * @method
     * Removes a listener from the command stack.
     * 
     * @param {graphiti.command.CommandStackListener} listener the listener to remove.
     */
    removeCommandStackEventListener:function(listener)
    {
       this.eventListeners.remove(listener);
    },
    
<span id='POST_UNDO-method-notifyListeners'>    /**
</span>     * @method
     * Notifies command stack event listeners that the command stack has changed to the
     * specified state.
     * 
     * @param {graphiti.command.Command} command the command
     * @param {Number} state the current stack state
     *
     **/
    notifyListeners:function(command,  state)
    {
      var event = new graphiti.command.CommandStackEvent(command, state);
      var size = this.eventListeners.getSize();
      for (var i = 0; i &lt; size; i++)
         this.eventListeners.get(i).stackChanged(event);
    }
});


</pre>
</body>
</html>
